<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Quick Clean — remove text by clone-stamp</title>
<style>
  :root{
    --ink:#eae7dc; --bg:#0a0b0f; --panel:#101216; --gold:#ffd66b;
    --line:rgba(255,255,255,.14);
  }
  html,body{height:100%; margin:0; background:#0b0e13; color:#dfe6f1;
            font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
  header{padding:10px 14px; border-bottom:1px solid var(--line);
         background:#0d1118; position:sticky; top:0; z-index:10}
  header .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  input[type=file]{color:#cbd5e1}
  select,button{background:#111827; color:#e5e7eb; border:1px solid var(--line);
                border-radius:10px; padding:8px 10px}
  button{cursor:pointer; font-weight:700}
  button.primary{background:#1f2937; border-color:#2c3442}
  #wrap{display:grid; place-items:center; padding:12px}
  canvas{max-width:95vw; max-height:70vh; background:#000; border-radius:12px;
         box-shadow:0 10px 40px rgba(0,0,0,.45)}
  .hint{opacity:.75; margin:6px 0 0 2px}
  .pill{padding:3px 8px; border:1px solid var(--line); border-radius:999px; opacity:.8}
</style>
</head>
<body>
  <header>
    <div class="row">
      <input id="file" type="file" accept="image/*">
      <label>Clone from:
        <select id="dir">
          <option value="top">Top</option>
          <option value="bottom">Bottom</option>
          <option value="left">Left</option>
          <option value="right">Right</option>
        </select>
      </label>
      <label>Feather(px):
        <select id="feather">
          <option>0</option><option>4</option><option selected>8</option>
          <option>12</option><option>16</option><option>24</option>
        </select>
      </label>
      <button id="undo">Undo</button>
      <button id="download" class="primary">Download PNG</button>
      <span class="pill">Tip: drag a rectangle over the text</span>
    </div>
    <div class="hint">If the patch looks off, switch “Clone from” and drag again.</div>
  </header>

  <div id="wrap">
    <canvas id="cv" width="1280" height="720"></canvas>
  </div>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const file = document.getElementById('file');
const dirSel = document.getElementById('dir');
const featherSel = document.getElementById('feather');
const undoBtn = document.getElementById('undo');
const dlBtn = document.getElementById('download');

let img = new Image();
let imgW=0, imgH=0, scale=1, offX=0, offY=0;
let start=null, dragging=false;
const history=[];

function fitCanvasToImage(){
  const vw = Math.min(window.innerWidth*0.95, 1400);
  const vh = Math.min(window.innerHeight*0.70, 1000);
  const s = Math.min(vw/imgW, vh/imgH);
  scale = s;
  cv.width  = Math.floor(imgW*s);
  cv.height = Math.floor(imgH*s);
  offX = 0; offY = 0;
}

function drawBase(){
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.drawImage(img, 0,0, imgW,imgH, 0,0, cv.width,cv.height);
}

file.onchange = e=>{
  const f = e.target.files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  img.onload = ()=>{
    imgW = img.naturalWidth; imgH = img.naturalHeight;
    fitCanvasToImage();
    drawBase();
    history.length=0;
    pushHistory();
  };
  img.src = url;
};

function pushHistory(){
  try{ history.push(ctx.getImageData(0,0,cv.width,cv.height)); }
  catch(e){ /* ignore if too large */ }
}

undoBtn.onclick = ()=>{
  if(history.length>1){
    history.pop();
    ctx.putImageData(history[history.length-1],0,0);
  }
};

function getRect(a,b){
  const x = Math.min(a.x,b.x), y = Math.min(a.y,b.y);
  const w = Math.abs(a.x-b.x), h = Math.abs(a.y-b.y);
  return {x,y,w,h};
}

function cloneStamp(rect, dir, feather){
  if(rect.w<4 || rect.h<4) return;
  // compute source rectangle
  let sx=rect.x, sy=rect.y;
  if(dir==='top')    sy = Math.max(0, rect.y - rect.h - 2);
  if(dir==='bottom') sy = Math.min(cv.height-rect.h, rect.y + rect.h + 2);
  if(dir==='left')   sx = Math.max(0, rect.x - rect.w - 2);
  if(dir==='right')  sx = Math.min(cv.width-rect.w, rect.x + rect.w + 2);

  // Save area under patch to allow soft edge
  const patch = ctx.getImageData(sx,sy,rect.w,rect.h);

  // Draw with slight blur to blend
  ctx.save();
  ctx.filter = 'blur(1.2px)';
  ctx.drawImage(cv, sx,sy,rect.w,rect.h, rect.x,rect.y,rect.w,rect.h);
  ctx.restore();

  // Feather edges
  if(feather>0){
    const g = ctx.createLinearGradient(rect.x, rect.y, rect.x+rect.w, rect.y);
    // use a mask via globalCompositeOperation
    ctx.save();
    ctx.globalCompositeOperation = 'destination-in';
    const rad = feather;
    // build rounded-rect gradient mask
    const mask = document.createElement('canvas');
    mask.width = rect.w; mask.height = rect.h;
    const m = mask.getContext('2d');
    m.fillStyle = '#000';
    m.fillRect(0,0,rect.w,rect.h);
    const grd = m.createRadialGradient(rad,rad,0, rad,rad,rad);
    m.globalCompositeOperation = 'destination-out';
    // four corners
    function corner(x,y){
      const g2 = m.createRadialGradient(x,y,0, x,y,rad);
      g2.addColorStop(0,'rgba(0,0,0,1)');
      g2.addColorStop(1,'rgba(0,0,0,0)');
      m.fillStyle=g2; m.beginPath(); m.arc(x,y,rad,0,Math.PI*2); m.fill();
    }
    corner(rad,rad);
    corner(rect.w-rad,rad);
    corner(rad,rect.h-rad);
    corner(rect.w-rad,rect.h-rad);
    // edges
    m.fillStyle='rgba(0,0,0,0.5)';
    m.fillRect(rad,0,rect.w-2*rad,rad);
    m.fillRect(rad,rect.h-rad,rect.w-2*rad,rad);
    m.fillRect(0,rad,rad,rect.h-2*rad);
    m.fillRect(rect.w-rad,rad,rad,rect.h-2*rad);

    ctx.drawImage(mask, rect.x,rect.y);
    ctx.restore();
  }
}

function pt(e){
  const r = cv.getBoundingClientRect();
  const x = (e.touches? e.touches[0].clientX: e.clientX) - r.left;
  const y = (e.touches? e.touches[0].clientY: e.clientY) - r.top;
  return {x:Math.max(0,Math.min(cv.width,x)), y:Math.max(0,Math.min(cv.height,y))};
}

function drawGuide(a,b){
  drawBase();
  const r = getRect(a,b);
  ctx.save();
  ctx.strokeStyle='rgba(255,255,255,.9)';
  ctx.setLineDash([6,4]);
  ctx.lineWidth=2;
  ctx.strokeRect(r.x+0.5,r.y+0.5,r.w,r.h);
  ctx.restore();
}

cv.addEventListener('mousedown', e=>{ if(!imgW) return; start = pt(e); dragging=true; });
cv.addEventListener('mousemove', e=>{ if(dragging) drawGuide(start, pt(e)); });
cv.addEventListener('mouseup',   e=>{
  if(!dragging) return;
  dragging=false;
  const r = getRect(start, pt(e));
  cloneStamp(r, dirSel.value, parseInt(featherSel.value,10)||0);
  pushHistory();
});

cv.addEventListener('touchstart', e=>{ if(!imgW) return; start = pt(e); dragging=true; e.preventDefault(); }, {passive:false});
cv.addEventListener('touchmove',  e=>{ if(dragging){ drawGuide(start, pt(e)); e.preventDefault(); } }, {passive:false});
cv.addEventListener('touchend',   e=>{
  if(!dragging) return;
  dragging=false;
  const r = getRect(start, start); // last point not reliable on touchend
  // use a default small patch around start if no drag
  const rr = {x:Math.max(0,start.x-80), y:Math.max(0,start.y-40), w:160, h:80};
  cloneStamp(rr, dirSel.value, parseInt(featherSel.value,10)||0);
  pushHistory();
});

dlBtn.onclick = ()=>{
  const a = document.createElement('a');
  a.download = 'cleaned.png';
  a.href = cv.toDataURL('image/png');
  a.click();
};
</script>
</body>
</html>
